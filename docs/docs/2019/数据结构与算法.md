
# 什么是时间复杂度
## 时间复杂度定义
* 在进行算法分析时 ,语旬总的执行次次`T(n)`是关子问题规模`n`的函数,进而分析`T(n)n`的变化情况并确定T（n）的数量级。
* 一般情况下,随着n的增大,T(n)增长最慢的算法为最优算法
* 算法的时间复杂度也就算法的度量，记作：`T（n）=O(f(n))`.它表示随问题规模n的增大，算法执行时间增长率和`f(n)`的增长率相同，乘坐算法的渐进时间复杂度。其中`f(n)`是问题规模n的某个函数
* 这样用大写 O()来体现算法时间复杂度的记法,我们称之为大 0 记法 。
* 常见的有常数阶O（1），线性阶O（n），对数阶O（logn），平方阶O（n2）

## 推导大O阶方法
* 用常熟1取代运行时间中所有的加法常熟
* 在修改后的次数中只保留最高阶项
* 如果最高阶项存在且不是1,则去除与这个项相乘的常数。得到的结果就是大O阶。

## 常数阶
高斯求和：求1+2+3+4+5+6…+n 结果集

``` java

public static void main(String[] args) {
    int  sum = 0,n = 100; // 执行一次
    sum = (1 + n) *(n/2); // 执行一次
    System.out.println(sum); //执行一次
}
```
这个算法的运行次数函数是`f(n) =3`.根据我们推导大 0 阶的方法,第一步就是
把常数项3改为1在保留最高阶项时发现,它根本没有最高阶项,所以这个算法的O(1).

## 线性阶
* 线性阶的循环结构会复杂很多。要确定某个算法的阶次,我们常常需要确定某个 特定语句或某个语句集运行的次数。因此,我们要分析算法的复杂度,关键就是要分 析循环结构的运行情况。

``` java

int i;
for (i = 0; i < n; i++){   

 /* 时间复杂度为O(1)的程序步骤序列 */
}
```
它的循环的时间复杂度为 O(n), 因为循环体中的代码须要执行 n 次。

## 对数阶


``` java

int count = 1; 
while (count < n){
 count = count * 2;
 /* 时间复杂度为O(1)的程序步骤序列 */
}
```
* 由于每次count 乘以2之后,就距离n更近了一分 。 也就是说,有多少n个2相乘后大于 ,则会退出循。由 $2^x$=n得到x=log2n。 所以这个循环的时间复杂度为`O(logn)`。
* 二分查找算法的时间复杂度就是O(logn)。O(logn)的意思是以log为底数（你如果采用二分法,那么就会以2为底数,三分法就会以3为底数）比如当数据增大256倍时，耗时只增加8倍：

```
O(logn)=O(log256)

2x2=4                  //第1次
2x2x2=8                //第2次
2x2x2x2=16             //第3次
2x2x2x2x2=32           //第4次
2x2x2x2x2x2=64         //第5次
2x2x2x2x2x2x2=128      //第6次
2x2x2x2x2x2x2=256(n)   //第7次 7个2相乘后=n
2x2x2x2x2x2x2x2>n      //第8次 个2相乘后大于

```

 **`O(nlogn)`同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。** 


![常见的时间复杂度](https://images.gitee.com/uploads/images/2019/0211/223305_a061aa73_1478371.png)

# 线性表和二分查找法

- 线性查找又称顺序查。基本思路是从第一个记录开始，
- 逐个比较记录的关键字，直到和给定的K值相等，则查找成功；
- 若比较结果与文件中n个记录的关键字都不等，则查找失败。
- 时间复杂度：O(N)

## 二分查找法

- 二分查找法又叫折半查找法。比如小时候玩的猜数字游戏

* 胖虎说：大熊你猜猜我现在心中想的数字是什么。给你一个范围1-100之间，不限次数猜，猜不中就打你一次，看你需要被我打多少次才可以猜出来（心中想的是25）。

* 大熊想：.... 心中犯嘀咕。这不是明摆着欺负我。不行我得拿出吃奶的力气快速想出来。减少挨打的份 大熊随口说两个50

* 胖虎说：不对。随即甩手就是一嘴巴。![输入图片说明](https://images.gitee.com/uploads/images/2019/0130/172824_a7d37664_1478371.png) 并说太高了
* 大熊：.... 真TM难。思考一番。那我就在减半 随口说是数字：25 ![输入图片说明](https://images.gitee.com/uploads/images/2019/0130/173112_2aca200c_1478371.png) 这次就猜对了

类似这种折半猜数字的方法就是二分法查找。

### 基本思路
* 首先设置一个左标记为0和一个右标标记为当前数组长度，
* 第二步 让当前待查元素与表中间元素进行匹配，如果一致则直接返回中间索引，
* 第三步 如果小于中间索引则让右标记等于当前中间索引，
* 第四步 如果大于中间索引，则让左标示等于当前中间索引

 **二分法查找比线性查找才查询次数上会大大减少。所以效率也就高了。就是要待查询的表为有序表，并且只对查询效率有所优化，
当修改和插入数据的时候这种效率就很低了。** 

### 代码示范

``` java
public class 二分法查找 {
	public static void main(String[] args) {
		 int[] number = {1,2,3,4,5,6,7,8,9,10};
	     int key = 10;
	     int result =halfSort(number, key);
	     System.out.println("查找出的下标："+result);
	}
	public static int halfSort(int[] data,int key){
	     int min,mid,max;
	     max=data.length-1;
	     min=0;
	    while (min<=max){
		mid=(min+max)/2;  //折半
		if(key<data[mid]){ //如查找值比中值小
		   max=mid-1;	//最高下标调证到中值下标的小一位
		}else if(key>data[mid]){
		   min=mid+1;
		}else{
		  return  mid;
	        }
	     }
		return  -1;
	  }
}
```
## 线性表

0个或多个数据元素的有限序列。 首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继 。 

### 线性表的顺序存储结构 

线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 

#### 顺序存储结构
 **插入算法思路:** 
* 如果插入位置不合理，抛出异常;
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;
* 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置;
* 将要插入元素填入位置 i 处，表长加 1 。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0131/170133_bdd74d0b_1478371.png)

 **删除算法的思路:** 
* 如果删除位置不合理，抛出异常 i
* 取出删除元素;
* 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动 一
个位置;
* 表长减 1 。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0131/170258_222b86d2_1478371.png)

 **代码实现** 

``` java
public interface MyList<E> {
	 int size();
	 boolean contains(Object o);
	 void add(int i,E e)throws Exception;
	 void add(E e)throws Exception;
	 void remove(int i)throws Exception ;
	 String toArray();
}


public class MyArrayList<E> implements MyList<E> {
	
	//数组作为线性表的存储空间
	private  Object[] elementData;

	//线性表的当前长度
	private int size;

	public MyArrayList(int initialCapacity) {
		//初始化数据大小
		this.elementData=new Object[initialCapacity];
		
		this.size=0;
	}

	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean contains(Object o) {
	     if (o == null){
	            for (int i = 0; i < size; i++)
	                if (elementData[i]==null)
	                    return true;
	        }else{
	            for (int i = 0; i < size; i++)
	                if (o.equals(elementData[i])){
	                	return true;
	                }   
	    }
		return false;
	}

	@Override
	public void add(int i, E e) throws Exception{
		if(size==elementData.length){
			  throw new Exception("存储空间已满");
		}
		if(i<0 || i>size){
			  throw new Exception("添加参数下标越界");
		}
	    for (int j = size; j > i; j--){
	    	// 插入位置及之后的元素后移(下标加1)  比如 123  插入元素4 到的2的位置
			 elementData[j] = elementData[j - 1]; ;
			 System.out.println("移动："+toArray());
		 }

	 	 elementData[i] = e; //插入
	     ++size; //长度增加
		 System.out.println("移动："+toArray());
	}

	/**
	 * 插入算法的思路;
	, 如果插入位置不合理，抛出异常;
	• 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;
	• 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位
	置;
	• 将要插入元素填入位置 i 处;
	• 表长加 1 。
	 */
	@Override
	public void add(E e)throws Exception {
		if(size==elementData.length){
			throw new Exception("存储空间已满");
		}
		  elementData[size++] =e;

	}
	
	/**
	 * 	 删除算法的思路:
		• 如果删除位置不合理，抛出异常 i
		• 取出删除元素;
		• 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动 一
		个位置;
		• 表长减 1 。
	 */
	@Override
	public void remove(int i)throws Exception {
		if (i < 0 || i > size - 1){
			 throw new Exception("删除位置不合法");
		}
		for (int j = i; j < size - 1; j++)  {
			  elementData[j] = elementData[j + 1];// 被删除元素之后的元素左移  
		 }
		  size--; // 表长度减1  
	}
	@Override
	public String toArray() {
		StringBuilder str=new StringBuilder();
		str.append("toArray:[");
		for (int i = 0; i <size; i++) {
			str.append(elementData[i]+",");
		}
		str.append("]");
		return str.toString();
	}

	
	public static void main(String[] args) {
		MyList<Integer> list=new MyArrayList<>(10);
		try {
			list.add(1);
			list.add(2);
			list.add(3);
			System.out.println(list.size());
			System.out.println(list.toArray());
//			list.remove(0);
//			System.out.println(list.size());
//			System.out.println(list.toArray());
			list.add(1, 4);
			System.out.println(list.toArray());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}


}

```
#### 链式存储结构
* 链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，
这组存储单元可以是连续的，也可以是不连续的。
* 除了存储其本身的信息之外，还需存储一个指示其直接后继的信息指针
* 链式存储结构是基于指针实现的。我们把一个数据元素和一个指针称为结点。

```
数据域：存数数据元素信息的域。
指针域：存储直接后继位置的域。
```

1. 单链表
* 单链表是以指针作为连接，各个节点都由next指针指向下一个节点的地址，将各个节点相互连接起来形成一个单向链表
* 单链表分为有头结点和非头结点两种。一般都是有头结点的
* 头结点即在链表的首元结点之前附设的一个结点，该结点的数据域中不存储线性表的数据元素，其作用是为了对链表进行操作时，可以对空表、非空表的情况以及对首元结点进行统一处理，编程更方便。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0201/165040_fc574de0_1478371.png "单链表")

 **带头结点的单链表的插入操** 

![输入图片说明](https://images.gitee.com/uploads/images/2019/0201/174818_61955d68_1478371.png)

* 采用带头结点的单链表结构，插入时。不管是在中间插入还是头部插入元素。操作方式都是统一的，改变的是插入元素位置上一个节点的next指针区域的指向。以及插入元素next指针区域的指向
* 头结点即在链表的首元结点之前附设的一个结点，该结点的数据域中不存储线性表的数据元素，其作用是为了对链表进行操作时，可以对空表、非空表的情况以及对首元结点进行统一处理，编程更方便。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0203/192405_37c81c2d_1478371.png)

 **代码实现** 

``` java
public class Node {
	Object element; // 数据域
	Node next; // 指针域

	// 头结点的构造方法
	public Node(Node nextval) {
		this.next = nextval;
	}

	// 非头结点的构造方法
	public Node(Object obj, Node nextval) {
		this.element = obj;
		this.next = nextval;
	}

	// 获得当前结点的指针域
	public Node getNext() {
		return this.next;
	}

	// 获得当前结点数据域的值
	public Object getElement() {
		return this.element;
	}

	// 设置当前结点的指针域
	public void setNext(Node nextval) {
		this.next = nextval;
	}

	// 设置当前结点数据域的值
	public void setElement(Object obj) {
		this.element = obj;
	}

	public String toString() {
		return this.element.toString();
	}
}

public class MyLinkList {
	Node head; // 头指针
	Node current;// 当前结点对象
	int size;// 结点个数

	public MyLinkList() {
		// 初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点。
		this.head = current = new Node(null);
		this.size = 0;// 单向链表，初始长度为零。
	}

	//使用当前结点对象 定位到要操作结点的前一个结点。
	public void index(int index) throws Exception {
		if (index < -1 || index > size - 1) {
			throw new Exception("参数错误！");
		}
		// 说明在头结点之后操作。
		if (index == -1){
			// 第一个数据元素结点的下标是0，那么头结点的下标自然就是-1
			return;
		}
		current = head.next;
		int temp=0;	 	//临时变量 用户循坏判断当前节点是否到达
		while (current!=null && temp<index){
				//循环找到插入节点的前一个节点
				current=current.next;
				temp++;
		}
	}


	/**
	 * 删除思路：
	 *
	 * 1。定位到当前要删除的下标的对像的前一个节点
	 * 2. 通过改变当前删除对象前一个节点的指针域。》指向当前要删除对象的指针域指向的下一个节点。
	 * @param index
	 * @throws Exception
	 */
	public void delete(int index) throws Exception {
		// 判断链表是否为空
		if (isEmpty()) {
			throw new Exception("链表为空，无法删除！");
		}
		if (index < 0 || index > size) {
			throw new Exception("参数错误！");
		}
		index(index - 1);// 定位到要操作结点的前一个结点对象。
		current.setNext(current.next.next);
		size--;
	}

	/**
	 * 获取思路：
	 * 		从头节点开始遍历。用临时变量temp记录遍历的次数。一直遍历等于index就不会再行循坏，直接取出当前下标的节点
	 * @param index
	 * @return
	 * @throws Exception
	 */
	public Object get(int index) throws Exception {
		if (index < -1 || index > size - 1) {
			throw new Exception("参数非法！");
		}
		current = head.next;
		int temp=0;	 	//临时变量 用户循坏判断当前节点是否到达
		while (current!=null && temp<index){
			//循环找到插入节点的前一个节点
			current=current.next;
			temp++;
		}
		return current.getElement();
	}

	/**
	 * 指定位置插入节点
	 * @param index
	 * @param obj
	 * @throws Exception
	 */
	public void save(int index, Object obj) throws Exception {
		if (index < 0 || index > size) {
			throw new Exception("参数错误！");
		}
		index(index-1);//定位到要操作结点的前一个结点对象。
		current.setNext(new Node(obj,current.next));
		size++;

	}

	/**
	 * 未指定下标末尾插入
	 * @param obj
	 * @throws Exception
	 */
	public void save(Object obj) throws Exception {
		/**
		 * 1.判断当前节点指向一下节点的指针域是否为空
		 * 如果指针域为空 说明是此节点是末尾节点
		 * 直接在尾部修改默认节点的指针域执指向新增的节点，并把新增的节点的指针域指向null
		 */
		while (current.next!=null){
			//循环判断当前节点指针域是否有下一个节点
			current=current.next;
		}
		current.setNext(new Node(obj, current.next));
		size++;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	public int size() {
		return this.size;
	}

	public static void main(String[] args) throws  Exception {
		MyLinkList list=new MyLinkList();
//		list.save(1);
		list.save(0,0);
		list.save(1,111);
		list.save(2,222);
		System.out.println("删除之前：");
		for (int i = 0; i < list.size; i++) {
			System.out.print(list.get(i) + " ");
		}
		System.out.println();
		list.delete(1);
		System.out.println("删除之后：");
		for (int i = 0; i < list.size; i++) {
			System.out.print(list.get(i) + " ");
		}
	}

}

```
#### 顺序表和单链表的比较
 **顺序表：** 
* 优点：在存, 读数据时, 不管是哪个位置，时间复杂度都是 0(1) ; 
*缺点：插入或删除时，时间复杂度都是 O(n)。需要运动大量元素当线性表长度变化较大时，难以确定存储空间的容量会产生存储空间“碎片” 

 **单链表：** 
* 优点：主要优点是不需要预先给出数据元素的最大个数。另外，单链表插入和删除操作时不需要移动数据元素；
* 缺点：主要缺点是每个结点中要有一个指针，因此单链表的空间利用率略低于顺序表的。另外，单链表不支持随机读取，单链表取数据元素操作的时间复杂度为O（n）；而顺序表支持随机读取，顺序表取数据元素操作的时间复杂度为O（1）。

# 什么是循坏链表

* 将单链表中终端结点的指针端自空指针改为指向头结点,就使整个单链表形成一 个环,这种头尾:相接的单链表称为单循环链表,简称循环链表。

## 循坏列表的生活情境
* 比出 ,你是一业务员, 家在上海。儒要经常出差,行程就是上海到北京一路上的 城市,找客户谈生意或分公司办理业务。你从上海出发,乘火车路经多个城市停留 后,再乘飞机返回上海,以后,每隔一段时间,你基本还要按照这样的行程开展业务

![输入图片说明](https://images.gitee.com/uploads/images/2019/0205/202815_5d6fe9d4_1478371.png)

* 有一次你先到南京开会，接下来要对以上的城市走一遍。此时有人对你说,不行,你得从上海开始,因为上海是第一站。 你会对这人说什么?神经病。哪有这么傻 的,直接回上海根本没有必要,你可以从南京开始,下一站蚌埠,直到北京,之后再 考虑走完上海及苏南的几个城市。显然这表示你是从当中一结点开始遍历整个链裴 , 这都是原来的单链表结构解决不了的问题。

## 循环链袭和单链表的主要差异
* 循环链袭和单链表的主要差异就在于循环的判断条件土,原沫是判断 `p->next(指针域)`
是否为空,现在则是 `p-> next` 不等于头结点,则循环未结束。
* 在单链表中,我们有了头结点时,我们可以用 0(1)的时间访问第一个结点,但对于要访问到最后一个结点,却需要 O(n)时间,因为我们需要将单链表全部扫描一编。
* 循环链表的尾指针方式就用0(1)的时间访问到尾部元素

## 代码实现
``` java
public class CycleLinkList {

    Node head; // 头指针
    Node current;// 当前结点对象
    int size;// 结点个数

    public CycleLinkList() {
        // 初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点。
        this.head = current = new Node(null);
        this.size = 0;// 单向链表，初始长度为零。
        this.head.next = this.head; //最后一个元素指针域指向头结点
    }

    //使用当前结点对象 定位到要操作结点的前一个结点。
    public void index(int index) throws Exception {
        if (index < -1 || index > size - 1) {
            throw new Exception("参数错误！");
        }
        // 说明在头结点之后操作。
        if (index == -1){
            // 第一个数据元素结点的下标是0，那么头结点的下标自然就是-1
            return;
        }
        current = head.next;
        int temp=0;	 	//临时变量 用户循坏判断当前节点是否到达
        while (current!=head && temp<index){
            //循环找到插入节点的前一个节点
            current=current.next;
            temp++;
        }
    }


    /**
     * 删除思路：
     *
     * 1。定位到当前要删除的下标的对像的前一个节点
     * 2. 通过改变当前删除对象前一个节点的指针域。》指向当前要删除对象的指针域指向的下一个节点。
     * @param index
     * @throws Exception
     */
    public void delete(int index) throws Exception {
        // 判断链表是否为空
        if (isEmpty()) {
            throw new Exception("链表为空，无法删除！");
        }
        if (index < 0 || index > size) {
            throw new Exception("参数错误！");
        }
        index(index - 1);// 定位到要操作结点的前一个结点对象。
        current.setNext(current.next.next);
        size--;
    }

    /**
     * 获取思路：
     * 		从头节点开始遍历。用临时变量temp记录遍历的次数。一直遍历等于index就不会再行循坏，直接取出当前下标的节点
     * @param index
     * @return
     * @throws Exception
     */
    public Object get(int index) throws Exception {
        if (index < -1 || index > size - 1) {
            throw new Exception("参数非法！");
        }
        index(index);
        return current.getElement();
    }

    /**
     * 指定位置插入节点
     * @param index
     * @param obj
     * @throws Exception
     */
    public void insert(int index, Object obj) throws Exception {
        if (index < 0 || index > size) {
            throw new Exception("参数错误！");
        }
        index(index-1);//定位到要操作结点的前一个结点对象。
        current.setNext(new Node(obj,current.next));
        size++;

    }

    /**
     * 未指定下标末尾插入
     * @param obj
     * @throws Exception
     */
    public void insert(Object obj) throws Exception {
        /**
         * 1.判断当前节点指向一下节点的指针域是否为空
         * 如果指针域为空 说明是此节点是末尾节点
         * 直接在尾部修改默认节点的指针域执指向新增的节点，并把新增的节点的指针域指向null
         */
        while (current.next!=null){
            //循环判断当前节点指针域是否有下一个节点
            current=current.next;
        }
        current.setNext(new Node(obj, current.next));
        size++;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return this.size;
    }


}

```

``` java
public class Node {
	Object element; // 数据域
	Node next; // 指针域

	// 头结点的构造方法
	public Node(Node nextval) {
		this.next = nextval;
	}

	// 非头结点的构造方法
	public Node(Object obj, Node nextval) {
		this.element = obj;
		this.next = nextval;
	}

	// 获得当前结点的指针域
	public Node getNext() {
		return this.next;
	}

	// 获得当前结点数据域的值
	public Object getElement() {
		return this.element;
	}

	// 设置当前结点的指针域
	public void setNext(Node nextval) {
		this.next = nextval;
	}

	// 设置当前结点数据域的值
	public void setElement(Object obj) {
		this.element = obj;
	}

	public String toString() {
		return this.element.toString();
	}


}

```
## 约瑟夫环
约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。通常解决这类问题时我们把编号从0~n-1，最后 [1]  结果+1即为原问题的解


``` java
public class Yuesefu {

    /**
     * 构建循环链表
     * @param totalCol
     * @return
     */
    public node createNodes(int totalCol){
        node head = null; //定义一个头结点
        node[] nodes = new node[totalCol]; //数组结点存放41个人
        for(int i = 0; i < totalCol ; i++){
            nodes[i] = new node();
            nodes[i].node = i+1 ; //数据域赋值  不能让从0开始赋值 +1
            if(i==0){ //为0时就是是头结点
                // 初始化头结点
                head = nodes[i];
            }else{
                //当前下标结点的前一个节点对象的指针域指向当前i的结点
                nodes[i-1].next = nodes[i];
            }
        }
        nodes[totalCol-1].next = head ; //最后一个结点的指针域指向头结点
        return head ;
    }

public void begin(int total,int key){
        int sort = 0 ; //删除的序号
        int n = total ; //总人数
        node head = createNodes(total);
        //判断循环链表是不是只剩下一个节点
        while(head.next != head){
            for(int i = 1 ; i < key-1 ; i++){
                //1 ：每报数为3的人前一个节点 也就是2 并替代当前头结点
                head = head.next;

            }
            //2：用一个临时节点代替为当前报数为3的结点
            node temp = head.next;
            System.out.println("第"+(++sort)+"个自杀的为："+temp.node);

            //3：使头结点的指针域指向报数为3的结点的next指向的结点
            head.next = temp.next;
            //替换头结点 等于当前报数为3的人结点  循环以上步骤直到最后一个结点自杀完毕
            head = head.next;

        }
        System.out.println("第"+(++sort)+"个自杀的为："+head.node);
    }

    public static void main(String[] args) {
        Yuesefu y = new Yuesefu();
        y.begin(41,3);
    }
}
class node {
    node next ; //指针域
    int node ; //数据域
    public node getNext() {
        return next;
    }
    public void setNext(node next) {
        this.next = next;
    }
    public int getNode() {
        return node;
    }
    public void setNode(int node) {
        this.node = node;
    }

}

```
算法流程如下：
* 1.初始化循环链表,从下标1开始自增赋值。头结点单数据域默认为空。单独处理不存放值
* 2.赋值到最后totalCol-1的结点  也就是尾部结点。它的指针域指向头结点形成单向循环链表。
* 3.循序开始判断链表是不是只剩下一个节点。也就是结点的指针域是否指向头结点。如果是就直接退出while并自杀此结点
* 4.当结点的指针域不是指向头结点时。循环操作i<k-1次循环找到当前报数为3的前一个节点。并使头结点替换
* 5 用一个临时节点代替为当前报数为3的结点（也就是步骤4找的结点的next指向）输出它已自杀
* 6.使头结点的指针域指向报数为3的结点的next指向的结点。最后替换头结点等于当前报数为3的人结点  循环以上步骤直到最后一个结点自杀完毕

![输入图片说明](https://images.gitee.com/uploads/images/2019/0205/232813_a3f64244_1478371.png)

# 双向循环链表


## 前言

今儿是大年初二,没事继续复习数据结构与算法。复习完双向链表下面就开始栈与队列的复习了。搞完这篇先去北京路溜达溜达。晚上在继续PMP和数据结构预算的学习

## 什么是双向循环链表

- 在单链袤的每个结点中,再设置一个指向其前驱结点的指针 域 。所以在双向链表中的结点都有两个指针域, 一个指向直接后继,另一个指向直接 前驱。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0206/135240_5015650a_1478371.png "双向链表")

## 双向循环链表的生活情境

- 比出 ,你是一业务员, 家在上海。儒要经常出差,行程就是上海到北京一路上的 城市,找客户谈生意或分公司办理业务。你从上海出发,乘火车路经多个城市停留 后,再乘飞机返回上海,以后,每隔一段时间,你基本还要按照这样的行程开展业务

![输入图片说明](https://images.gitee.com/uploads/images/2019/0205/202815_5d6fe9d4_1478371.png)

- 你平时都是从上海一路停留到北京的,可是这一次,你得先到北京开会,谁叫北京是首都呢,会就是多。开完会后,你需要例行公事,走访各个城市,此时你怎么办?。有人又出主意了,你可以先飞回上海,一路再乘火车走遍这儿个城市,到了北京后，你在飞回上海。你会感慨,人生中为什么总会有这样出馒主意的人存在呢?真要气死人才行。哪来这么麻烦,我一路从北京坐火车或汽车回去不就完了吗。
- 对呀,其实生活中类似的小智慧比比皆是,并不会那么的死板教条。我们的单链表,总是从头到尾找结点,难道就不可以正反遍历都可以吗?当然可以,只不过需要加点东西而已。

## 循环链袭和双向链表的主要差异

- 双向链表和单向的循环链表操作节本相同，只是在添加和删除操作时多 了一个改变前指针的操作

- 我们在单链表中,有了 next 指针,这就使得我们要查找下一结点的时同复杂度为0(1)。可是如果我们要查找的是上一结点的话,那最坏的时间复杂度就是 O(n)了,因为我们每次都要从头开始遍历查找。双向链表就可以解决此类问题

  

## 代码实现

``` java
public class MyLinkedList {
   Node head; // 头指针
    Node current;   // 当前结点对象
    int size;// 结点个数


    // 初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点。
    public MyLinkedList() {
        this.head = current = new Node(null);
        this.size = 0;// 单向链表，初始长度为零。
        this.head.next = head; //最后一个元素指针域指向头结点
        this.head.prior=head;
    }

    //使用当前结点对象 定位到要操作结点的前一个结点。
    public void index(int index) throws Exception {
        if (index < -1 || index > size - 1) {
            throw new Exception("参数错误！");
        }
        // 说明在头结点之后操作。
        if (index == -1){
            // 第一个数据元素结点的下标是0，那么头结点的下标自然就是-1
            return;
        }
        current = head.next;
        int temp=0;	 	//临时变量 用户循坏判断当前节点是否到达
        while (current!=head && temp<index){
            //循环找到插入节点的前一个节点
            current=current.next;
            temp++;
        }
    }


    /**
     * 删除思路：
     *
     * 1。定位到当前要删除的下标的对像的前一个节点
     * 2. 通过改变当前删除对象前一个节点的指针域。》指向当前要删除对象的指针域指向的下一个节点。
     * 3. 改变删除结点的下一个结点的前指针,指向删除结点的前一个结点
     * @param index
     * @throws Exception
     */
    public void delete(int index) throws Exception {
        // 判断链表是否为空
        if (isEmpty()) {
            throw new Exception("链表为空，无法删除！");
        }
        if (index < 0 || index > size) {
            throw new Exception("参数错误！");
        }
        index(index - 1);// 定位到要操作结点的前一个结点对象。
        //改变删除结点的前一个节点的next指向为要删除结点的下一个结点
        current.setNext(current.next.next);
        /**
         * 执行 current.setNext(current.next.next)后删除结点的前结点的next就指向了，删除结点的下一个结点了
         * 比如,a,b,c三个结点 删除b的话 此时a->next就指向了c 但是c的前指针还是指向b
         * 所以这个时就改变c的前指针指向a就完成删除操作了
         */
        current.next.setPrior(current);
        size--;
    }

    /**
     * 获取思路：
     * 		从头节点开始遍历。用临时变量temp记录遍历的次数。一直遍历等于index就不会再行循坏，直接取出当前下标的节点
     * @param index
     * @return
     * @throws Exception
     */
    public Object get(int index) throws Exception {
        if (index < -1 || index > size - 1) {
            throw new Exception("参数非法！");
        }
        index(index);
        return current.getElement();
    }

    /**
     * 指定位置插入节点
     * @param index
     * @param obj
     * @throws Exception
     */
    public void insert(int index, Object obj) throws Exception {
        if (index < 0 || index > size) {
            throw new Exception("参数错误！");
        }
        index(index-1);//定位到要操作结点的前一个结点对象。
        current.setNext(new Node(obj,current.next));
        current.next.setPrior(current);
        current.next.next.setPrior(current.next);
        size++;

    }

    /**
     * 未指定下标末尾插入
     * @param obj
     * @throws Exception
     */
    public void insert(Object obj) throws Exception {
        /**
         * 1.判断当前节点指向一下节点的指针域是否为空
         * 如果指针域为空 说明是此节点是末尾节点
         * 直接在尾部修改默认节点的指针域执指向新增的节点，并把新增的节点的指针域指向null
         */
        while (current.next!=null){
            //循环判断当前节点指针域是否有下一个节点
            current=current.next;
        }
        //找到末尾节点后。在末尾插入新的结点
        current.setNext(new Node(obj, current.next));
        //当前末尾节点的下一个节点 也就是新增加的结点的前指针指向当前找到的末尾结点
        current.next.setPrior(current);
        //当前末尾结点next-next也就是刚插入的结点的下一个结点前指针指向当前插入的结点
        current.next.next.setPrior(current.next);
        size++;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return this.size;
    }

    public static void main(String[] args) throws  Exception {
        MyLinkedList list=new MyLinkedList();
        list.insert(0,0);
        list.insert(1,111);
        list.insert(2,222);
        System.out.println("删除之前：");
        for (int i = 0; i < list.size; i++) {
            System.out.print(list.get(i) + " ");
        }
        System.out.println();
        list.delete(1);
        System.out.println("删除之后：");
        for (int i = 0; i < list.size; i++) {
            System.out.print(list.get(i) + " ");
        }
    }
}

```

结点模型

``` java
public class Node {
	Object element; //数据域
	Node next;  //后继指针域
	Node prior; //前驱指针域

	//头结点的构造方法
	public Node(Node nextval) {
		this.next = nextval;
	}

	//非头结点的构造方法
	public Node(Object obj, Node nextval) {
		this.element = obj;
		this.next = nextval;
	}

	//获得当前结点的后继结点
	public Node getNext() {
		return this.next;
	}

	//获得当前结点的前驱结点
	public Node getPrior() {
		return this.prior;
	}

	//获得当前的数据域的值
	public Object getElement() {
		return this.element;
	}

	//设置当前结点的后继指针域
	public void setNext(Node nextval) {
		this.next = nextval;
	}

	//设置当前结点的前驱指针域
	public void setPrior(Node priorval) {
		this.prior = priorval;
	}

	//设置当前结点的数据域
	public void setElement(Object obj) {
		this.element = obj;
	}

	public String toString() {
		return this.element.toString();
	}


}

```

# 什么是栈

![输入图片说明](https://images.gitee.com/uploads/images/2019/0207/230135_85cedb9e_1478371.png)

## 栈与队列的概述
* 栈是限定仅在表尾进行插入和删除操作的线性表 。 
* 队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表

## 栈的定义
* 我们把允许插入和删除的一端称为栈顶(top) ,另一端称为核底 (bottom),不含任何数据元素的称为空钱。栈又称为后进先出 (LastIn FilrstOut) 的线性表,简 称 LlFO 结构 。
* 首先它是一个统性表 ,也就是说,栈元素具有线性关系,即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作,这里表尾是指栈顶 ,而不是栈底 。

## 栈的顺序存储结构
* 栈的顺序存储其实也是线性表顺序存储 的简化,我 们简称为顺序栈。下标为 0 的一端作为栈底比较好,因为首元素都存在栈底,变化最小,所以让它作栈底 。

## 顺序栈代码实现

``` java

public interface Stack<E> {

    //返回栈的长度
     int length();
     //出栈
     E pop();

    //进栈
     void push(E element);

    //访问栈顶元素
     E peek();

    //判断栈是否为空
     boolean empty();

     //清空栈
     void clear();

     String toString();
}

/**
 * 栈的顺序存储结构
 * 栈是先进后出的线性表
 * @author qinxuewu
 * @create 19/2/7下午1:23
 * @since 1.0.0
 *
 */
public class SequenceStack<E> implements  Stack<E> {
    //定义栈长度  给个默认值
    private int capacity = 16;
    //保存顺序栈中元素的个数
    private int size;
    //定义一个数组用于保存顺序栈中的元素
    private Object[] elementData;

    public SequenceStack(){
        this.elementData = new Object[capacity];
        this.size=0;
    }
    //以指定的大小来创建栈
    public SequenceStack(int initSize){
        this.capacity=initSize;
        this.elementData = new Object[capacity];
        this.size=0;
    }

    @Override
    public int length() {
        return size;
    }

    /**
     * 出栈思路：
     * 1.判断当前炸是否为空
     * 2. 栈不为空。先进后出原则。直接去栈顶的元素出栈szie-1的元素
     * 3. 返回出栈的元素，
     *
     * @return
     */
    @Override
    public E pop() {
        if(empty()){
            throw new IndexOutOfBoundsException("栈已空不能出栈");
        }
        E oldValue = (E)elementData[size - 1];
        //让垃圾回收器及时回收，避免内存泄露
        elementData[--size] = null;
        return oldValue;
    }

    /**
     * 进栈:
     * 1. 判断当前默认的栈长度是否已用完
     * 2. 如果栈空间已用完每次增加16位的长度
     * 3. 在新的栈空间的末尾元素增加新元素
     *
     * @param element
     */
    @Override
    public void push(E element) {
        //炸已满  每次增加16的长度
        if((size+1)>capacity){
            capacity=capacity+16;
            elementData = Arrays.copyOf(elementData, capacity);
        }
        elementData[size++]=element;
    }

    /**
     * 访问访问栈顶元素：
     * 先进后出。访问栈顶元素
     * @return
     */
    @Override
    public E peek() {
        if(empty()){
            return null;
        }
        E value = (E)elementData[size - 1];
        return value;
    }

    @Override
    public boolean empty() {
        return size==0;
    }

    @Override
    public void clear() {
        for (int i = 0; i <size ; i++) {
            elementData[i] = null;
        }
        this.size=0;
    }

    @Override
    public String toString() {
        StringBuilder str=new StringBuilder();
        str.append("[");
        for (int i = 0; i <size ; i++) {
            str.append(elementData[i]+",");
        }
        str.append("]");
        return str.toString();
    }

    public static void main(String[] args) {
        SequenceStack<Integer> stack=new SequenceStack<>();
        for (int i = 0; i <50 ; i++) {
            stack.push(i);
        }
        System.out.println(stack.toString());
        System.out.println(stack.size);
        System.out.println(stack.pop());
        System.out.println(stack.toString());
    }
}

```
## 栈的链式存储结构
* 栈的链式存储结构简称为链栈。通常栈顶是放在单链表的头部，对于链栈来说，是不需要头结点的。
* 对于链栈来说,基本不存在栈满的情况,除非内存已经没有可以使用的空间
* 对于空栈来说,链表原定义是头指针指向空 , 那么链栈的空其实就是`top=null`的时候。

![输入图片说明](https://images.gitee.com/uploads/images/2019/0207/192856_72bf4050_1478371.png "链栈")

 **进栈思路** 
* 让栈顶top指向新创建的元素，并且新元素的next指针指向原来的栈顶元素

 **出栈思路** 
* 出栈就是把当前栈顶替换为栈顶的next指向的结点。然后释放原栈顶的next引用

![输入图片说明](https://images.gitee.com/uploads/images/2019/0207/190928_c675e44b_1478371.png)

## 链栈代码实现

``` java

public class LinkStack<T> {

    private class Node {
        private T data;
        // 指向下个节点的指针
        private Node next;
        // 无参构造器
        public Node() {
        }
        public Node(T data, Node next) {
            this.data = data;
            this.next = next;

        }
    }

    //链栈的栈顶元素
    private Node top;
    // 结点数量
    private int size;

    public  LinkStack(){
        //空链栈，top的值为null
        top = null;
    }

    // 以指定数据元素来创建链栈，该链栈只有一个元素
    public LinkStack(T element) {
        top = new Node(element, null);
        size++;
    }
    public int length() {
        return size;
    }

    /**
     * 进栈思路：
     * 让栈顶top指向新创建的元素，并且新元素的next指针指向原来的栈顶元素
     * @param element
     */
    public void push(T element) {
        top = new Node(element, top);
        size++;

    }

    /**
     * 出栈思路：
     * 出栈就是把当前栈顶替换为栈顶的next指向的结点。然后释放原栈顶的next引用
     * @return
     */
    public T pop() {
        Node oldTop = top;
        // 让top引用指向原栈顶元素的下一个元素
        top = top.next;
        // 释放原栈顶元素的next引用
        oldTop.next = null;
        size--;
        return oldTop.data;

    }

    // 访问栈顶元素，但不删除栈顶元素
    public T peek(){
        return top.data;
    }

    // 请空链栈
    public void clear() {
        top = null;
        size = 0;
    }



    public static void main(String[] args) {
        LinkStack<Integer> stack=new LinkStack<Integer>();

        for (int i = 0; i <5 ; i++) {
            stack.push(i);
        }
        System.out.println(stack.pop());
        System.out.println(stack.size);

    }
}

```
## 栈的应用(递归)
 **斐波那契数列实现** 

说如果兔子在出生两个月后,就有繁殖能力, 一对兔子每个月能生出一对小兔子 来。假设所有兔都不死,那么一年以后可以繁殖多少对兔子呢?

我们拿新出生的一对小兔子分析一下;第一个月小兔子没有繁殖能力,所以还是 一对 i 两个月后,生下一对小兔子数共有两对; 三个月以后,老兔子又生下一对,因 为小兔子还没有繁殖能力 , 所以一共是三对......依次类推可以列出下表(表 4-8-1)。
![输入图片说明](https://images.gitee.com/uploads/images/2019/0207/195632_7b99560c_1478371.png)

前面相邻两项之和,构成了后一项

``` java
public class DiGuiTest {
    public static void main(String[] args) {
        for (int i=1;i<=12;i++){
            System.out.println(test(i));
        }
    }
    /**
     *
     * @param n 月份
     */
    public static int test(int n){
        if(n==1 || n==2){
            /**
             * 两个月后新出生的兔子才有繁殖能力。
             * 所以前两个月都没有兔子出生 都是开始的第一对兔子
             */
            return  1;
        }
        //前面相邻两项之和,构成了后一项
        return  test(n-1)+test(n-2);
    }
}
```

# 什么是队列


## 队列的概述
队列是一种先进先出 (First 10 First Out) 的线性表,简称 FIFO。允许插入的一 端称为队尾,允许删除的一端称为队头

![队列](https://images.gitee.com/uploads/images/2019/0208/094901_d7e4e114_1478371.png)

## 队列的顺序存储
* 顺序存储的队列需建立一个大于n的数组,并把队列的所有元素存储在数组的前n个单元,数组下标0的一端即是队头.所谓的入队列操作,其实就是在队尾追加一个元素,不需要移动任何元素,因此时间复杂度O(1)

* 与栈不同的是,队列元素的出列是在队头,即下标为队列中的所有元素都得向前移动,以保证队列的队头,也就是下标为0的位置不为空,此时时间复杂度为O(n)
 

``` java
public class QueueTest1<E> {

    private  Object[] elementData;
    //默认队列容量为10
    private final int DEFAULT_CAPACITY = 3;
    //容量
    private int capacity;
    //头指针 总是指向出队的索引
    private int front = 0;
    //尾指针 总是下一个插入元素的索引
    private int  rear = 0;

    //初始化队列
    public  QueueTest1(){
        this.capacity = DEFAULT_CAPACITY;
        elementData = new  Object[capacity];
    }

    public  QueueTest1(int initialCapacity){
        this.capacity = initialCapacity;
        elementData = new  Object[capacity];
    }

    //队列长度
    public int length(){
        return rear - front;
    }
    //判是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    /**
     * 入队：
     * 队尾插入元素
     * @param e
     */
    public void add(E e){
        //判断当前尾指针索引是否大于队列的容量 下标从0开始 所以减1
        if(rear>capacity-1){
            System.out.println("插入元素："+e+" 时队列已满 ");
        }
        elementData[rear++]=e;
    }

    /**
     * 出队：
     *  总是队头删除元素
     * @return
     */
    public E deQueue(){
        //获取头指针的元素
        E  e= (E) elementData[front];
        /**
         * 改变头指针的索引自增加+1
         * 并把之前头指针指向的元素赋值null 以便垃圾回收
         * front++ 先执行赋值null  下次再进入之前fornt就是1
         */
        elementData[front++] = null;
        return e;
    }

    public static void main(String[] args) {
        QueueTest1 q=new QueueTest1();
        q.add(1);
        q.add(2);
        q.add(3);

        System.out.println("size:"+q.length());
        System.out.println(q.deQueue());
        System.out.println("deQueue->size:"+q.length());
        q.add(4);  //此时会发生下标越界。报异常 

    }
}

```

当我们采用顺序队列的时候，如果采用“元素不前移”的机制，
当尾指针到达上边界时，就会认为队列已满，但此时低端空间由于出队可能还有空闲空间。

## 循坏队列
* 所以解决假溢出的办法就是后面满了 ,就再从头开始,也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列 


``` java
/**
 * 循坏队列
 *
 * 所以解决假溢出的办法就是后面满了 ,
 * 就再从头开始,也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列
 * @author qinxuewu
 * @create 19/2/8上午11:14
 * @since 1.0.0
 */
public class QueueTest2<E> {
    private Object[] objs;
    private int front = 0;// 头指针
    private int rear = 0;// 尾指针
    private int size;// 空间大小
    private int length = 0;

    //初始化队列
    public  QueueTest2(int size){
        this.size = size;
        objs = new Object[size];
    }

    //判是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 判满
    public boolean isFull() {
        if ((rear + 1) % size == front) {
            return true;
        }
        return false;
    }
    /**
     * 入队：
     * 队尾插入元素
     * @param e
     */
    public boolean add(E e){
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % size;
        objs[rear] = e;
        length++;
        return true;
    }

    /**
     * 出队：
     *  总是队头删除元素
     * @return
     */
    public Object deQueue(){
        Object n = null;
        if (!isEmpty()) {
            front = (front + 1) % size;
            n = objs[front];
            objs[front] = null;
            length--;
        }
        return n;
    }

    public static void main(String[] args) {
        QueueTest2 q=new QueueTest2(4);
        q.add(1);
        q.add(2);
        q.add(3);
        System.out.println("size:"+q.length);
        System.out.println(q.deQueue());
        System.out.println("1:deQueue->size:"+q.length);
        q.add(4);
        System.out.println("2:deQueue->size:"+q.length);
        System.out.println(q.deQueue());
        System.out.println(q.deQueue());
        System.out.println(q.deQueue());
    }
}

```
## 队列的链式存储
* 队列的链式存储结构,其实就是线性表的单链表,只不过它只能队尾进，队头出而已, 我们把它简称为链队列。为了操作上的方便,我们将队头指针指向链队列的头结点。而队尾指针指向终端结点。

![队列的链式存储结构](https://images.gitee.com/uploads/images/2019/0208/125825_93fa9a00_1478371.png)

* 人队操作时,其实就是在链表尾部插入结点
* 出队操作时,就是头结点的(next指向)后继结点出队,将头结点的next改为当前出队结点的nextzhi指向的结点, 若链表除头结点外只剩一个元素时, 则需将rear指向头结点


``` java
public class QueueTest3 {
    //头指针
    private Node head;
    //尾指针
    private Node rear;
    // 队列的长度
    private int length;


    private class Node {
        Object element; // 数据域
        Node next; // 指针域
        // 无参构造器
        public Node() {
        }
        public Node(Object element) {
            this.element=element;
        }
    }
    // 初始化队列，空头指针
    public QueueTest3() {
        this.head=new Node();
        this.rear=head; // 初始化时数据为空
        this.length=0;
    }
    // 初始化队列，有数据头指针
    public QueueTest3(Object obj) {
        head = new Node(obj);
        rear = head;
        length = 0;
    }

    /**
     * 入队：
     * 在链表尾部插入结点
     * @param obj
     * @throws Exception
     */
    public void add(Object obj){
        Node temp=new Node(obj);
        // 队列使用尾插法
        rear.next = temp; //修改尾指针的next指向新添加的结点
        rear = temp; //更新队首指针新结点
        this.length++;
    }

    /**
     *  出队：
     *
     *  出队操作时,就是头结点的后继结点出队,
     *  将头结点的后继改为它后面的结点,
     *  若链表除头结点外只剩一个元素时, 则需将 rear 指向头结点
     * @return
     */
    public Node deQueue(){
        Node temp;
        if(length==0){
            //无法删除
            temp=null;
        }else{
            if(length==1){

                //头结点的后继结点出队
                temp=head.next;
                //置空下一个节点就可以了
                head.next=null;
                //若链表除头结点外 只剩一个元素时, 则需将 rear 指向头结点
                this.rear=head;
                length--;
            }else{
                //头结点的后继结点出队
                temp= head.next;
                //将头结点的next, 改为出队结点它后面的结点
                this.head.next=this.head.next.next;
                length--;
            }
        }
        return  temp;
    }

    public static void main(String[] args) {
        QueueTest3 q=new QueueTest3();
        q.add(1);
        q.add(2);
        q.add(3);
        System.out.println("init: "+q.length);
        System.out.println("deQueue: "+q.deQueue().element);
        System.out.println("deQueue: "+q.deQueue().element);
        System.out.println("deQueue: "+q.deQueue().element);
        System.out.println("deQueue->size: "+q.length);

    }

}

```

![](https://images.gitee.com/uploads/images/2019/0208/134413_32798c49_1478371.png)

## 循环队列与链队列的比较
* 从时间上,其实它们的基本操作都是常数时间,即都为0(1)的,不过循环队列是先申请好空间,使用期间不释放,而对于链队列,每次申请和释放结点也会存在一些时间开销。
* 对于空间上来说,循环队列必须有一个固定的长度,所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题,尽管它需要一个指针域, 会产生 一些空间上的开销,但也可以接受 。所以在空间上,链队列更加灵活。
* 总的来说,在可以确定队列长度最大值的情况下 ,建议用循环队列,如果你无法预估队列的长度时,则用链队列。

![队列](https://images.gitee.com/uploads/images/2019/0208/141249_42b56dad_1478371.png)

# 什么是树形结构
## 树的概述
* 树是n个结点的有限集。n=O时称为空树，在任意一棵非空树中:有且仅有一个特定的称为根(Root)的结点: 
* 当 n> 1 时,其 余结点可分为 m(m>O)个互不相交的有限集 T1 T2、 ......Tm, 其中每一个集合本身又是一棵树,并且称为根的子树。
* 子树的个数没有限制,但它们一定是互不相交的

![树形结构](https://images.gitee.com/uploads/images/2019/0209/135906_ec2e11f1_1478371.png)

* 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。
* 度为0的结点称为叶结点(Leaf)或终端结点;
* 度不为0的结点称为非终端结点或分支结点 。 
* 除根结点之外,分支结点也称为内部结点。树的度,是树内各结点的度的最大值 。

![](https://images.gitee.com/uploads/images/2019/0209/140232_86fa5349_1478371.png)
因为这棵树结点的度的最大值是结点D的度,为3,所以树的度也为3

## 树的存储结构
### 双亲表示法
* 我们人可能因为种种原因,没有孩子,但无论是谁都不可能是从石头里蹦出来的,所以是人一定会有父母。树这种结构也不例外,除了根 结点外,其余每个结点,它不一定有孩子,但是一定有且仅有一个双亲。

* 假设以一组连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位，也就是说,每个结点除了知道自己是谁以外,还知道它的双亲在哪里

![双亲表示法](https://images.gitee.com/uploads/images/2019/0209/151624_83bb97db_1478371.png)

由于根结点是没有双亲的,所以我们约定根结点的位置域设置为-1,这也就意味着,我们所有的结点都存 有包双亲的位置。

![](https://images.gitee.com/uploads/images/2019/0209/181343_316d405e_1478371.png)

这样的存储结构,我们可以根据结点的 parent 指针很容易找到色的双亲结点,所 用的时间复杂度为0(1),直到parent为一1时,表示找到了树结点的根。

# 什么是二叉树


## 概述
 **二叉树是树的特殊一种，具有如下特点：** 
* 每个结点最多有两颗子树，结点的度最大为2。
* 左子树和右子树是有顺序的，次序不能颠倒。
* 即使某结点只有一个子树，也要区分左右子树。

![](https://images.gitee.com/uploads/images/2019/0209/200448_a431aa80_1478371.png)


## 二叉树五种基本形态
1. 空二叉树。
2. 只有一个根结点。
3. 根结点只有左子树。
4. 根结点只有右子树。
5. 根结点既有左子树又有右子树。

![](https://images.gitee.com/uploads/images/2019/0211/122736_ebc8c730_1478371.png)

## 特殊二叉树

### 斜树
* 斜树一定要是斜的,但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树 。
* 斜树有很明显的特点,就是每 一层都只有一个结点,结点的个数与二叉树的深度相同 。

![左斜树和右斜树](https://images.gitee.com/uploads/images/2019/0209/200824_28905b8c_1478371.png)

### 满二叉树
* 在一棵二叉树中,如果所有分支结点都存在左子树和右子树,并且所有叶子都在同一层上,这样的二叉树称为满二叉树
* 单是每个结点都存在左右子树,不能算是满二叉树,还必须要所有的叶子都在同一层上,这就做到了整棵树的平衡

![满二叉树](https://images.gitee.com/uploads/images/2019/0209/201158_4cb5d6ae_1478371.png)

### 完全二叉树
* 对一棵具有n个结点的二叉树按层序编号,如果编号为`i`的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同,则这棵二叉树称为完全二叉树

![完全二叉树](https://images.gitee.com/uploads/images/2019/0209/204720_77b85ac1_1478371.png)

满二叉树一定是一棵完全二叉树,但完全二叉树不一定是满的 。
完全二叉树的所有结点与同样深度的满二叉树,它们按层序编号相同的结点是一 一对应的

* 像图 6-5-7 中的树 1,因为5结点 没有左子树,却有右子树,那就使得按层序编号的第 10 个编号空档了。
* 同样道理,图 6-5-7 中的树2,由于3结点没有子树,所以使得 6、7 编号的位置空挡了。
* 图 6-5-7 中的树3又是因为5编号下没有子树造成第 10 和第 11 位置空档。
* 只有图 6-5-6 中的 树,尽管它不是满二叉树,但是编号是连续的,所以它是完全二叉树。

![](https://images.gitee.com/uploads/images/2019/0209/204309_8d2b5fa9_1478371.png)

 **完全二叉树的特点:** 
* 叶子结点只能出现在最下两层。
* 最下层的叶子一定集中在左部连续位置。
* 倒数二层,若有叶子结点,一定都在右部连续位置。
* 如果结点度为 1,则该结点只有左孩子,即不存在只有右子树的情况。 同样结点数的二叉树,完全二叉树的深度最小。

### 二叉树的性质
* 在二叉树的第i层上至多有2的i-1次方个结点 (($2^i-1$))。
* 深度为k的二叉树至多有2的k次方减1个结点($2^k-1$)。

* 对任何一棵二叉树 T,如果其终端结点数为$n_0$,度为2的结点数为$n_2$,则$n_0$=$n_2$+1
* 比如图 6-6-1 的例子,结点总数为 10,宫是由 A、 B、 c、 D 等度为 2 结点, F、 G、H、 l、J等度为0的叶子结点和E这个度为1的结点组成。 总和为4+1+5=10。

![](https://images.gitee.com/uploads/images/2019/0210/142451_da0f5876_1478371.png)

* 具有 n 个结点的完全二叉树的深度为[logn2n]+1

 **如果对一棵有 n 个结点的完全二叉树(其深度为 [logn2n]+1) 的结点按层 序编号(从第 1 层到第[logn2n]+1层,每层从左到右),对任一结点 i (1<=i<=n) 有:** 

1. 如果`i=1` ,则结点 i 是二叉树的棍,无双亲;如果i> 1,则其双亲是结点 $\frac{i}{2}$。
2. 如果`2*i>n`,则结点 i 左孩子(结点i为叶子结点) ;否则其左孩子是结点2*i。
3. 如果`2*i+1>0`,则结点i无右孩子;否则其右孩子是结点`2*i+1`.

![](https://images.gitee.com/uploads/images/2019/0210/155854_5f37a31e_1478371.png)

* i=l 时就是根结点。 i>1 时,比如结点7的双亲就是7/2=3, 结点9它的双亲就是9/2=4
* 第二条, 比如结点 6,因为 2X6=12 超过了结点总数 10,所以结点 6 元左孩子 , 它是叶子结点。 同样,而结点5, 因为2XS=10正好是结点,总数10,所以它的左孩子 是结点 10。 
* 第三条,比如结点 5,因为 2X5+1=l1,大于结点总数 10,所以它无右孩子。 而 结点 3,因为 2X3吐=7小于 10,所以宫的右孩子是结点 7

## 二叉树的顺序存储结构
* 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点,井且结点的存储位
置,也就是数组的下标要能体现结点之间的逻辑关系,比如双亲与孩子的关系,左右 兄弟的关系等。
* 顺序存储 结构一般只用于完全二叉树。


``` java
package com.example.qxw.tree;

import java.util.Arrays;

/**
 *  二叉树的顺序存储结构:
 *
 *  二叉树的顺序存储结构就是用一维数组存储二叉树中的结点,井且结点的存储位 置,
 *  也就是数组的下标要能体现结点之间的逻辑关系,比如双亲与孩子的关系,左右 兄弟的关系等
 *
 *  顺序存储结构一般只用于完全二叉树
 *
 * @author qinxuewu
 * @create 19/2/9下午6:12
 * @since 1.0.0
 */


public class TreeTest01<T> {
    //二叉树的默认深度
    private final int DEFAULT_DEEP=16;
    //二叉树的深度
    private int k;
    //用来存储数组的长
    private int length;
    //数据区域
    private Object[] data;


    //初始化二叉树
    public TreeTest01(){
        k=DEFAULT_DEEP;
        //深度为k的二叉树至多有2的k次方减1个结点
        length=(int) Math.pow(2, k);
        data=new Object[length];
    }
    public TreeTest01(int deep){
        this.k=deep;
        length=(int) Math.pow(2, deep);
        data=new Object[length];

    }
    //初始化二叉树 指定根结点
    public TreeTest01(T element,int deep){
        this.k=deep;
        length=(int) Math.pow(2, deep);
        data=new Object[length];
        data[0]=element;
    }

    //根据元素查找在二叉树出现的第一个位置
    public int indexOf(T element){
        for(int i=0;i<data.length;i++){
            if(data[i].equals(element)){
                return i;
            }
        }
        return -1;
    }
    //根节点
    public T getRoot(){
        return (T) data[0];
    }

    //

    /**
     * 查找指定结点的父节点
     *
     * 根据二叉树的性质：
     * 如果i=1 ,则结点i是二叉树的根,无双亲;如果i> 1,则其双亲是结点(i/2)
     * 所以得出求父节点公式：(index-1)/2  因为数据下标从0开始所以index-1。
     */
    public T getParent(int index){
        if(index==0){
            throw new RuntimeException("该节点不存在父节点");
        }
        return (T) data[(index-1)/2];
    }

    //判断二叉树是否为空
    public boolean isEmpty(){
        return data[0]==null;
    }

    //获取指定结点
    public T get(int index){
        if(index>length||index<0){
            throw new RuntimeException("超出底层数组范围");
        }
        return (T) data[index];
    }


    /**
     * 为指定结点添加子节点
     * @param index
     * @param element
     * @param left 是否是左结点
     */
    public void add(int index,T element,boolean left){
        if(data[index]==null){
            throw new RuntimeException("该节点为空，不能添加子节点");
        }
        if(index*2+1>length||index*2+2>length){
            throw new RuntimeException("超出底层数组范围");
        }
        if(left){
            /**
             * 根据二叉树的性质：
             * 如果对一棵有 n 个结点的完全二叉树的结点按层序编号(每层从左到右))对任一结点i
             * 如果 2*i>n(i=结点编号即下标 n=结点总数),则结点i无左孩子
             * 所以得出data[index*2+1]下标处如果为空就不存在左子节点可以进行插入
             */
            if(data[index*2+1]!=null){
                throw new RuntimeException("该节点已经存在左子节点");
            }else{
                data[index*2+1]=element;
            }
        }else{
            /**
             * 根据二叉树的性质：
             * 如果对一棵有 n 个结点的完全二叉树的结点按层序编号(每层从左到右))对任一结点i
             * 如果 2*i+1>n(i=结点编号即下标 n=结点总数),则结点i无右孩子
             * 所以得出data[index*2+1++]下标处如果为空就不存在右子节点可以进行插入
             */
            if(data[index*2+2]!=null){
                throw new RuntimeException("该节点已经存在右子节点");
            }else{
                data[index*2+2]=element;
            }
        }
    }

    //获取指定结点的右节点
    public T getRight(int index){
        if(index*2+1>length||index*2+2>length){
            throw new RuntimeException("超出底层数组范围");
        }
        return (T) data[index*2+2];
    }

    //获取指定结点的左结点
    public T getLeft(int index){
        if(index*2+1>length||index*2+2>length){
            throw new RuntimeException("超出底层数组范围");
        }
        return (T) data[index*2+1];
    }
    public String toString(){
        if(data[0]==null){
            return "[]";
        }else{
            return Arrays.toString(data);
        }
    }


    public static void main(String[] args) {
        //完全二叉树
        TreeTest01<String> tree=new TreeTest01<>("A",4);
        tree.add(0,"B",true); //左结点
        tree.add(0,"C",false);//右结点
        tree.add(1,"D",true);
        tree.add(1,"E",false);
        tree.add(2,"F",true);
        tree.add(2,"G",false);
        tree.add(3,"H",true);
        tree.add(3,"I",false);
        tree.add(4,"J",true);
        System.out.println(tree.toString());
        System.out.println(tree.get(2)); // 获取下标2的结点：C
        System.out.println(tree.getParent(2));// 获取下标2的双亲结结点：A
        System.out.println(tree.getRight(2));// 获取下标2的右子结点：G
        System.out.println(tree.getLeft(2));// 获取下标2的左子结点：F
    }


}

```


## 二叉树的链式存储结构
* 二叉树每个结点最多有 两个孩子,所以为它设计一个数据域和两个指针域是 比较自然的想法, 我们称这样的 链表叫做二叉链衰

![二叉链表](https://images.gitee.com/uploads/images/2019/0210/171823_adbfb6e8_1478371.png)

data是数据区域。lchild和 民rchild都是指针域分别存放指向左孩子和右孩子的指针

![](https://images.gitee.com/uploads/images/2019/0210/172028_aecf4cbf_1478371.png )

## 遍历二叉树
* 二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点.使得每个结点被访问-次 旦仅被访问一次 。
* 二叉树的遍历次序不同于线性结构,最多也就是从头至尾、循环、双向等简单的 遍历方式。树的结点之间不存在唯一的前驱和后继关系,在访问 一个结点后,下一个 被访问的结点面临着不同的选择 。

## 二叉树遍历方法
如果我们限制了从左到右的习惯方式,那么主要就分为四种 
1.  **前序遍历** 
* 若二叉树为空,则空操作返回,否则先访问根结点,然后前序遍历左子 树 , 再前序遍历右子树 

![前序遍历](https://images.gitee.com/uploads/images/2019/0210/172554_fa339fdd_1478371.png)

2.  **中序遍历** 
* 若树为空,则空操作返回,否则从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树,然后是访问根结点,最后中序遍历右子树 。

![中序遍历](https://images.gitee.com/uploads/images/2019/0210/172814_7a39c8e7_1478371.png)

3.  **后序遍历** 
* 若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点 

![后序遍历](https://images.gitee.com/uploads/images/2019/0210/172929_aa6f2c17_1478371.png)

4.  **层序遍历** 
* 若树为空,则空操作返回,否则从树的第一层,也就是根结点开始访问, 从上而下逐层遍历,在同一层中, 按从左到右的颇用才结点逐个访问

![层序遍历](https://images.gitee.com/uploads/images/2019/0210/173145_f0ad5e65_1478371.png)

 **JAVA实现二叉树的链式存储以及遍历** 

``` java
public class TreeNode<E> {
    private E data;   //数据域
    private TreeNode<E> lchild;  //左孩子
    private TreeNode<E> rchild;  //右孩子

    TreeNode(){}

    TreeNode(E e){
        this.data = e;
    }

    TreeNode(E data,TreeNode<E> lchild, TreeNode<E> rchild){
        this.data = data;
        this.lchild = lchild;
        this.rchild = rchild;
    }

    public void setData(E data){
        this.data = data;
    }

    public E getData(){
        return this.data;
    }

    public void setLchild(TreeNode<E> lchild){
        this.lchild = lchild;
    }

    public TreeNode<E> getLchild(){
        return this.lchild;
    }

    public void setRchild(TreeNode<E> rchild){
        this.rchild = rchild;
    }

    public TreeNode<E> getRchild(){
        return this.rchild;
    }
}

public class BinaryTree<E> {

    private TreeNode<E> root;  //根节点
    private List<TreeNode> nodeList = null;   //二叉树节点的链式结构

    public BinaryTree(){

    }
    public BinaryTree(TreeNode<E> root){
        this.root = root;
    }

    //把一个数组转化为一颗完全二叉树
    public TreeNode<E> buildTree(E[] array){
        nodeList = new LinkedList<TreeNode>();
        //将数组中的元素依次转换为TreeNode节点，存放于链表中
        for(int i=0; i< array.length; i++){
            nodeList.add(new TreeNode(array[i]));
        }
        //对前（array.length / 2 - 1）个父节点，按照父节点与孩子节点的数字关系建立完全二叉树
        for(int j=0; j < (array.length/2-1);j++){
            /**
             * 根据二叉树的性质：
             * 如果对一棵有 n 个结点的完全二叉树的结点按层序编号(每层从左到右))对任一结点i
             * 如果 2*i>n(i=结点编号即下标 n=结点总数),则结点i无左孩子
             * 如果 2*i+1>n(i=结点编号即下标 n=结点总数),则结点i无右孩子
             */

            //左孩子 (2*i+1）
            nodeList.get(j).setLchild(nodeList.get(j*2+1));
            //右孩子 2*i+2）
            nodeList.get(j).setRchild(nodeList.get(j*2+2));
        }
        //最后一个父节点：因为最后一个父节点可能没有右孩子，所以单独处理
        int index = array.length/2 -1;
        //左孩子
        nodeList.get(index).setLchild(nodeList.get(index*2+1));
        //右孩子：如果数组的长度为奇数才有右孩子
        if(array.length % 2 == 1){
            nodeList.get(index).setRchild(nodeList.get(index*2+2));
        }
        root=nodeList.get(0); //设置根节点
        return root;
    }

    //得到树的高度
    public int height(TreeNode<E> node){
        if(node == null){
            return 0;
        }else{
            int i = height(node.getLchild());
            int j = height(node.getRchild());
            return (i<j)?(j+1):(i+1);
        }
    }

    //递归计算节点的总个数
    public int size(TreeNode<E> node){
        if(node == null){
            return 0;
        }else{
            //根节点+左子节点+右子节点
            return 1+ size(node.getLchild())+size(node.getRchild());
        }
    }


    /**
     * 递归实现先序遍历
     * 先访问根结点,然后前序遍历左子 树 , 再前序遍历右子树
     * @param node
     */
    public void preOrder(TreeNode<E> node){
        if(node != null){
            System.out.print(node.getData() + " ");
            preOrder(node.getLchild());
            preOrder(node.getRchild());
        }
    }

    /**
     * 递归实现中序遍历
     * 从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树,
     * 然后是访问根结点,最后中序遍历右子树
     * @param node
     */
    public void inOrder(TreeNode<E> node){
        if(node != null){
            inOrder(node.getLchild());
            System.out.print(node.getData() + " ");
            inOrder(node.getRchild());
        }
    }


    /**
     * 递归实现后序遍历
     * 从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点
     * @param node
     */
    public void postOrder(TreeNode<E> node){
        if(node != null){
            postOrder(node.getLchild());
            postOrder(node.getRchild());
            System.out.print(node.getData() + " ");
        }
    }

    /**
     * 层序遍历
     *
     * 从树的第一层,也就是根结点开始访问, 从上而下逐层遍历,
     * 在同一层中, 按从左到右的颇用才结点逐个访问
     * @param root
     */
    public void levelOrder(TreeNode<E> root){
        Queue<TreeNode<E>> nodeQueue = new LinkedList<TreeNode<E>>();
        TreeNode<E> node = null;
        nodeQueue.add(root);  //将根节点入队
        while(!nodeQueue.isEmpty()){  //队列不空循环
            node = nodeQueue.peek();
            System.out.print(node.getData()+" ");
            nodeQueue.poll();     //队头元素出队
            if(node.getLchild() != null){     //左子树不空，则左子树入队列
                nodeQueue.add(node.getLchild());
            }
            if(node.getRchild() != null){     //右子树不空，则右子树入队列
                nodeQueue.add(node.getRchild());
            }
        }
    }

    public static void main(String[] args) {
        //将一个数组转化为一颗完全二叉树
        //将一个数组转化为一颗完全二叉树
        Object[] array = {1,2,3,4,5,6,7,8};
        BinaryTree bt = new BinaryTree();
        TreeNode root = bt.buildTree(array);
        System.out.println("height: "+bt.height(root));
        System.out.println("size: "+bt.size(root));
        System.out.println("先序遍历：");
        bt.preOrder(root);
        System.out.println();

        System.out.println("中序遍历：");
        bt.inOrder(root);
        System.out.println();

        System.out.println("中序遍历：");
        bt.levelOrder(root);
        System.out.println();

        System.out.println("层次遍历：");
        bt.levelOrder(root);

    }
}

```
# 查找
## 顺序表查找
* 顺序查找又叫线性查找，是最基本的查找技术。
* 它的查找过程是:从表中第一个(或最后一个)记录开始，逐个进行记亲的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录;如果直到最后一个(或第一个)记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功 。

## 有序表查找
### 二分查找
* 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;
* 若给定值小于中间记录的关键字，则在中间记录的左边部分继续查找；
* 若给定值大于中间记录的关键字，则在中间记录的右边部分继续查找。不断重复以上过程。


``` java
public static void main(String[] args) {
            int[] number = {1,2,3,4,5,6,7,8,9,10};
	     int key = 5;
	      System.out.println("递归查找出的下标："+binSearch(number,0,number.length-1,key));
	     System.out.println("查找出的下标："+halfSort(number, key));
	}
	
	public static int halfSort(int[] data,int key){
		int left=1, right=data.length;		
		while(left<=right){
			int mid = (left+right)/2;
			if(data[mid]>key){
				right = mid-1;
			}else if(data[mid]<key){
				left = mid+1;
			}else{
				return mid;
			}
		}
		return 0;

	  }
	
	
    // 二分查找递归实现   
    public static int binSearch(int srcArray[], int start, int end, int key){   
        int mid = (end - start) / 2 + start;   
        if (srcArray[mid] == key) {   
            return mid;   
        }   
        if (start >= end) {   
            return -1;   
        } else if (key > srcArray[mid]) {   
            return binSearch(srcArray, mid + 1, end, key);   
        } else if (key < srcArray[mid]) {   
            return binSearch(srcArray, start, mid - 1, key);   
        }   
        return -1;   
    } 
```
### 插值查找
* 插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。
* 计算公式：`int mid=left+(right-left)*(key-data[left])/(data[right]-data[left]);`
* 从时间复杂度来 看，它也是O(logn),，但对表长比较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多
* 反之，数组中如果分布类似币，1，2，2000，2001.....999998, 999999}这种极端不均匀的数据，用插值查找未必是很合适的选择

上述二分法查找计算中间值部分更换为计算公式即可实现插值查找
``` java

public static int halfSort(int[] data,int key){
    int left=0, right=data.length-1;		
     while(left<=right){
          int mid=left+(right-left)*(key-data[left])/(data[right]-data[left]); //插值
	      if(data[mid]>key){
		    right = mid-1;
		}else if(data[mid]<key){
		   left = mid+1;
		}else{
		  return mid;
	        }
	     }
	      return 0;

}

```
## 线性索引查找
* 索引就是把一个关键字与宫对应的记录相关联的过程 , 一个索引由若干个索引项构成,每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息
* 所谓线性索引就是将索引项集合组织为线性结构,也称为索引表。

### 稠密索引
* 稠密索引是指在线性索引中,将数据集中的每个记录对应一个索引项
* 对于稠密索引这个索引表来说,索引项一定是按照关键码有序的排列。索引项有序也就意味着,我们要查找关键字时,可以用到折半、插值、斐被那契 等有序查找算法,大大提高了效率 ,

![](https://images.gitee.com/uploads/images/2019/0214/222722_0c9ce82a_1478371.png)

``` java

public class Index {
    public int key;
    public Object value;
    public int size;//分块存储数量
    
}

public class Student implements Comparable {
    public Student(int no, String name) {
        this.no = no;
        this.name = name;
    }
    public int no;
    public String name;

    @Override
    public String toString() {
        return "Student{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public int compareTo(Object o) {
        Student other = (Student) o;
        if (no < other.no) //这里比较的是什么 sort方法实现的就是按照此比较的东西从小到大排列
            return -1;
        if (no > other.no)
            return 1;
        return 0;
    }

    public static void main(String[] args) {
        Student[] array=new Student[]{
                new Student(2,"2222"),new Student(1,"1111"),
                new Student(3,"3333"),new Student(4,"44444"),
                new Student(5,"5555"),new Student(6,"7777"),
        new Student(7,"7777"),new Student(8,"8888")};

        int key=4;

        System.out.println(denseIndex(array,8).toString());
    }

    //创建稠密索引表
    public static Student denseIndex(Student[] array, int key) {
        if (array != null && array.length > 0) {
            //排序 对于稠密索引这个索引表来说,索引项一定是按照关键码有序的排列
            Arrays.sort(array);
            Index[] list = new Index[array.length];
            //建立索引
            for (int i = 0; i < array.length; i++) {
                Index index = new Index();
                index.key = array[i].no;
                index.value = array[i];
                list[i] = index;
            }

            //根据索引关键码搜索
            int code = binarySearch(list, key);
            if (code != -1) {
                return (Student) list[code].value;
            }
        }
        return null;
    }

    public static int binarySearch(Index[] array, int key) {
        if (array.length > 0) {
            int low, high, mid;
            low = 0;
            high = array.length - 1;
            while (low <= high) {
                mid = (low + high) / 2;//折半
                if (key < array[mid].key)
                    high = mid - 1;
                else if (key > array[mid].key)
                    low = mid + 1;
                else
                    return mid;
            }
        }

        return -1;
    }

}
```


### 分块索引
* 稠密索引因为索引项与数据集的记录个数相同,所以空间代价很大。为了减少索引项的个数,我们可以对数据集进行分块,使其分块有序,然后再对每一块建立一个索引项,从而减少索引项的个数。

 **分块有序,是把数据集的记录分成了若干块,并且这些块需要满足两个条件:** 
* 块内无序,即每一块内的记录不要求有序。
* 块间有序,例如,要求第二块所有记录的关键字均要大于第一块中所有记录的关键字,第三块的所有记录的关键字均要大于第二块的所有 记录关键字......因为只有块间有序,才有可能在查找时带来放率。

对于分块有序的数据集,将每块对应一个索引项,这种索引方法叫做分块索引。我们定义的分块索引的索引项结构分三个数据项 
* 最大关键码,它存储每一块中的最大关键字,这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大 i
* 存储了块中的记录个数,以便于循环时使用;
* 用于指向块首数据元素的指针,便于开始对这一块中记景进行遍历。

![分块索引](https://images.gitee.com/uploads/images/2019/0214/215816_f541bb11_1478371.png)

在分块索引表中查找,就是分两步进行:
* 在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的, 因此很容易利用折半、插值等算法得到结果。例如,在图 8-5-4的数据集中 查找62,我们可以很快可以从左上角的索引表中由 57<62<96 得到 62 在第三 个块中。
* 根据块首指针找到相应的块,并在块中顺序查找关键码。因为块中可以是无序的,因此只能顺序查找。


``` java
public class BlockIndex {
	public int[] index; //索引表
	public ArrayList[] list; //块内元素 可以无序
	
	//初始化分块索引表
	public BlockIndex(int[] index) {
			this.index=index;
			this.list=new ArrayList[index.length];
			for (int i = 0; i < list.length; i++) {
				// 分配元素到各自的块内
				list[i]=new ArrayList<>();
			}
	}

	/**
	 * 分配块内元素
	 */
	public void insert(int value) {
		for (int i = 0; i < index.length; i++) {
			if(value<index[i]){
				list[i].add(value);
				break;
			}
		}
	}
	/**
	 * 打印每块元素
	 */
	public void printAll() {
		for (int i = 0; i < list.length; i++) {
			ArrayList l = list[i];
			System.out.print("ArrayList" + i + ":");
			for (int j = 0; j < l.size(); j++) {
				System.out.print(l.get(j) + "  ");
			}
			System.out.println();
		}
	}
	
	/**
	 * 二分查找
	 */
	private int binarysearch(int value) {
		int start = 0;
		int end = index.length;
		int mid = -1;
		while (start <= end) {
			mid = start + (end - start) / 2;
			if (index[mid] > value) {
				end = mid - 1;
			} else {
				start = mid + 1;
			}
		}
		return start;
	}
	
	/**
	 * 查找元素
	 */
	public boolean search(int data) {
		int i = binarysearch(data);
		// 先二分查找确定在哪个块
		for (int j = 0; j < list[i].size(); j++) {
			// 然后顺序查找在该块内哪个位置
			if (data == (int) list[i].get(j)) {
				System.out.println(String.format("查找元素为  %d 第: %d块  第%d个 元素",data, i + 1, j + 1));
				return true;
			}
		}
		return false;
	}

	public static void main(String[] args) {
		int [] data={1,12,22,10,18,23,5,15,27};
		//分为三个块 
		int[] index = {10, 20, 30};
		BlockIndex blocksearch=new BlockIndex(index);
		for (int i = 0; i < data.length; i++) {
			blocksearch.insert(data[i]);
		}
		blocksearch.printAll();

		blocksearch.search(18);
	}

}
```


### 倒排索引
* 现在有两篇极短的英文"文章"一一其实只能算是句子,我们暂认为是文章,编号分别是 1 和 2。

![](https://images.gitee.com/uploads/images/2019/0214/221354_a482bdfc_1478371.png)

* 假设我们忽略掉如 `books`,`friends` 中的复数 `s` 以及如 `A` 这样的大小写差异。我们可以整理出这样一张单词表,如表 8-5-1 所示,并将单词做了排序 , 也就是表格显示了每个不同的单词分别出现在哪篇文章中,比如 `good` 它在两篇文章中都有出现,而`is`只是在文章 2 中才有,

![](https://images.gitee.com/uploads/images/2019/0214/221648_559679e0_1478371.png)

* 有了这样一张单词衰,我们要搜索文章,就非常方便了.如果在搜索框中搜索`book`关键字。系统就先在这张单词表中有序查找 "book",找到后将它对应的文章编号 1 和 2的文章地址(通常在搜索引擎中就是网页的标题和链接)返回,并告诉你,查找到两条记录,用时 0.0001 秒。由于单词表是有序的,查找效率很高,返回的又只是文章的编号,所以整体速度都非常快 。

 **在这里这张单词表就是索引表, 索引项的通用结构是:** 
* 次关键码.例如上面的"英文单词"。
* 记录号衰,例如上面的"文章编号" 。

其中记录号表存储具有相同次关键字的所有记录的记录号。这样的索引方法就是倒排索引

 **优点：** 
* 倒排索引的优点显然就是查找记录非常快,基本等于生成索引表后,查找时都不 用去读取记录,就可以得到结果。

 **缺点：** 
* 它的缺点是这个记录号不定长。维护比较困难，插入和删除操作都要做相应的处理。

``` java
package com.example.chazhao;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
 
 /**
  * 倒排索引
  * 倒排索引的优点显然就是查找记录非常快,基本等于生成索引表后,查找时都不 用去读取记录,就可以得到结果
  * 
  * 它的缺点是这个记录号不定长。维护比较困难，插入和删除操作都要做相应的处理
  * 
  * 1.txt：i live in hangzhou where are you

	2.txt：i love you i love you
	
	3.txt：i love you today is a good day
  */
public class IntertedIndex {
	// 存储单词对应 多个文件列表
	private Map<String, ArrayList<String>> map=new HashMap<>();
	//文路径列表
	private ArrayList<String> list;
	//词频统计
	private Map<String, Integer> nums=new HashMap<>();
	
	public void CreateIndex(String filepath){
		String[] words = null;
		try {
		
			File file=new File(filepath);
			BufferedReader reader=new BufferedReader(new FileReader(file));
			String s=null;
			while((s=reader.readLine())!=null){
				//获取单词
				words=s.split(" ");
			}
			for (String string : words) {
				if (!map.containsKey(string)) {
					//集合汇总不不存在当前单词
					list=new ArrayList<String>();
					list.add(filepath);
					map.put(string, list); //单词对应的 文件列表
					nums.put(string, 1); //单词出现的次数 首次默认1
				}else {
					list=map.get(string);
					//如果没有包含过此文件名，则把文件名放入
					if (!list.contains(filepath)) {
						list.add(filepath);
					}
					//文件总词频数目
					int count=nums.get(string)+1;
					nums.put(string, count);
				}
			}
			reader.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		IntertedIndex index=new IntertedIndex();
		for(int i=1;i<=2;i++){
			String path="C:\\Users\\admin\\Desktop\\"+i+".txt";
			index.CreateIndex(path);
		} 
		for (Map.Entry<String, Integer> num : index.nums.entrySet()) {
			System.out.println("单词:"+num.getKey()+"   		"
					+ "出现次数："+num.getValue()+"  "+index.map.get(num.getKey()));
		}
	}
}

```


## 二叉排序树
 **二叉排序树 又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。** 
* 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值
* 若它的右子树不空 ，则右子树上所有结点的值均大于宫的根结点的值
* 它的左、右子树也分别为二叉排序树
* 它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。
* 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度

![](https://images.gitee.com/uploads/images/2019/0215/213818_8adb2c23_1478371.png)

### 插入节点
（1）首先将20与根节点进行比较，发现比根节点小，所以继续与根节点的左子树30比较。

（2）发现20比30也要小，所以继续与30的左子树10进行比较。

（3）发现20比10要大，所以就将20插入到10的右子树中。

![](https://images.gitee.com/uploads/images/2019/0215/213856_c099b5a5_1478371.png)

### 查找节点
比如我们要查找节点10，那么思路如下：

（1）还是一样，首先将10与根节点50进行比较，发现比根节点要小，所以继续与根节点的左子树30进行比较。

（2）发现10比左子树30要小，所以继续与30的左子树10进行比较。

（3）发现两值相等，即查找成功，返回10的位置。


### 删除节点
 **删除节点的情况相对复杂，主要分为以下三种情形：** 

删除的是叶节点(即没有孩子节点的)。比如20，删除它不会破坏原来树的结构，最简单。如图所示

![](https://images.gitee.com/uploads/images/2019/0215/214035_e641e7f9_1478371.png)

删除的是单孩子节点。比如90，删除它后需要将它的孩子节点与自己的父节点相连。情形比第一种复杂一些。

![](https://images.gitee.com/uploads/images/2019/0215/214117_c946e1e3_1478371.png)


删除的是有左右孩子的节点。比如根节点50

这里有一个问题就是删除它后，谁将作为根节点？利用二叉树的中序遍历，就是右节点的左子树的最左孩子。

![](https://images.gitee.com/uploads/images/2019/0215/214211_b773dc95_1478371.png)


``` java
public class Node {
	private int value;// 结点值
	protected Node leftChild;// 左孩子结点
	protected Node rightChild;// 右孩子结点

	public Node(int value) {
		this.value = value;
		this.leftChild = null;
		this.rightChild = null;
	}

	public void setValue(int value) {
		this.value = value;
	}

	public int getValue() {
		return value;
	}

}

public class SortTree {
	// 递归实现二叉排序树的插入
	public void insertBST(Node root, int value) {
		if (root == null) {
			root = new Node(value);
			root.leftChild = null;
			root.rightChild = null;
		}

		//大于根节点则 分配在右子树
		if (value > root.getValue()) {
			//如果右子树为空则直接赋值给右子树
			if (root.rightChild == null) {
				root.rightChild = new Node(value);
			} else {
				//右子树不为空，则递归判断，以右子树为父节点的
				insertBST(root.rightChild, value);
			}
		} else {
			//左子树分配原理同上
			if (root.leftChild == null) {
				root.leftChild = new Node(value);
			} else {
				insertBST(root.leftChild, value);
			}
		}
	}

	// 递归实现二叉排序树查找
	public Node searchBSTByRecursion(Node root, int value) {
		if (root == null) {
			return null;
		}

		if (root.getValue() == value) {// 步骤1
			return root;
		} else if (value < root.getValue()) {// 步骤2
			return searchBST(root.leftChild, value);
		} else if (value > root.getValue()) {// 步骤3
			return searchBST(root.rightChild, value);
		}

		return null;// 如果没找到，就返回null
	}

	// 非递归实现二叉排序树查找
	public Node searchBST(Node root, int value) {
		Node temp = root;
		while (temp != null) {
			if (temp.getValue() == value) {
				return temp;
			}
			if (value < temp.getValue()) {
				temp = temp.leftChild;
			} else {
				temp = temp.rightChild;
			}
		}

		return null;
	}

	// 二叉排序树的删除
	public Node deleteBST(Node root, int value) {
		Node cur = root; // 当前结点
		Node parent = null; // 待删结点的父结点
		Node delNode = null; // 在后面用来引用待删结点
		Node temp = null; // 作为一个局域内的根结点

		// 查找待删结点p和待删结点的父结点f
		while (cur != null) {
			if (value == cur.getValue()) {
				break;
			}
			parent = cur;
			if (value > cur.getValue()) {
				cur = cur.rightChild;
			} else {
				cur = cur.leftChild;
			}
		}

		// 当前结点为null，即没有找到待删结点。 此时cur指向待删结点
		if (cur == null) {
			return null;
		}
		// 待删结点只有右子树
		if (cur.leftChild == null) {
			// 待删结点的父结点为null，即待删结点为根结点
			if (parent == null) {
				// 根结点为待删结点的右子树
				root = cur.rightChild;
			} else if (parent.leftChild == cur) { // 待删结点为父结点的左子树
				// 把待删结点的右子树作为待删结点父结点的左子树
				parent.leftChild = cur.rightChild;
			} else { // 待删结点为父结点的右子树
				parent.rightChild = cur.rightChild;
			}
		} else {// 待删结点有左子树，要找左子树的最右下角的结点
			temp = cur;
			delNode = cur.leftChild; // 此时s指向待删结点
			while (delNode.rightChild != null) {// 查找待删结点的最右下角结点
				temp = delNode;
				delNode = delNode.rightChild;
			}
			if (temp == cur) {// 即，待删结点没有右子树，把左子树向上移动
				temp.leftChild = delNode.leftChild;
			} else {// 即，待删结点有右子树
				temp.rightChild = delNode.leftChild;
			}
			cur.setValue(delNode.getValue());
		}

		return root;
	}

	//先序遍历
    public void preOrder(Node root) {
        if(root != null) {
            System.out.print(root.getValue() + " ");
            preOrder(root.leftChild);
            preOrder(root.rightChild);
        }
    }

    //中序遍历
    public void inOrder(Node root) {
        if(root != null) {
            inOrder(root.leftChild);
            System.out.print(root.getValue() + " ");
            inOrder(root.rightChild);
        }
    }
    //后序遍历
    public void postOrder(Node root) {
        if(root != null) {
            postOrder(root.leftChild);
            postOrder(root.rightChild);
            System.out.print(root.getValue() + " ");
        }
    }


	public static void main(String[] args) {
		SortTree t=new SortTree();
		Node root=new Node(44); //根节点
		t.insertBST(root, 21); //左子树		
		t.insertBST(root, 65); //右子树
		t.insertBST(root, 14);
		t.insertBST(root, 72);
		t.insertBST(root, 32);
		t.insertBST(root, 58);
		t.insertBST(root, 80);
		
		t.preOrder(root);
//		t.deleteBST(root, 44);
		System.out.println();
		t.preOrder(t.deleteBST(root, 44));
	}
}

```

## 平衡二叉树(AVL树)
* 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1
* 它是一种高度平衡的二叉排序树。要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树， 旦左子树和右子树的深度之差的绝对值不超过 1
* 我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF。平衡二叉树上所有结点的平衡因乎只可能是-1 ， 0 和 1.

![平衡二叉树](https://images.gitee.com/uploads/images/2019/0218/163302_4fd48473_1478371.png)

* 图二 59 比 58 大却是 58 的左子树，这是不符合二叉排序树的定义的
* 图 3 不是平衡二叉树的原因就在于，结点 58 的左子树高度为 2 ，而右子树为空，二者差大于了绝对值 1 

距离插入结点最近的，且平衡困子的绝对值大于 1 的结点为根的子树，我们称为最小不平衡子树

![最小不平衡子树](https://images.gitee.com/uploads/images/2019/0218/164659_90233695_1478371.png)

* 上图当新插入结点37时，距离它最近的平衡因子绝对值超过1的结点是58 (即它的左子树高度2减去右子树高度的，所以从58 开始以下的子树为最小不平衡子树 。

